---
listing_title: "Clase 01"
title: |
  | \includegraphics[width=5cm]{Imagen5.png}  
  | ECO5008 Modelos predictivos
subtitle: Clase 01 - Pronósticos y Simulación en la Gestión Hospitalaria
format: pdf
editor: visual
author:   
  - Sebastián Egaña Santibáñez [{{< fa brands inbox >}}](mailto:segana@fen.uchile.cl)
code-block-bg: true
code-block-border-left: "#FF0000"
---

------------------------------------------------------------------------

# Enlaces del profesor

[{{< fa brands link >}}](https://segana.netlify.app) https://segana.netlify.app

[{{< fa brands github >}}](https://github.com/sebaegana) https://github.com/sebaegana

[{{< fa brands linkedin >}}](https://www.linkedin.com/in/sebastian-egana-santibanez/) https://www.linkedin.com/in/sebastian-egana-santibanez/

------------------------------------------------------------------------

```{r load_packages, message=FALSE, warning=FALSE, include=FALSE}
library(fontawesome)
```

# Clase 01

# Conceptos iniciales

## Conceptos básicos de series de tiempo

Se habla de series de tiempo cuando nos referimos a una variable sobre la cual observamos su comportamiento a través del tiempo. Un ejemplo conocido, puede ser el principal indicador de productividad de un país, denominado Producto interno bruto (PIB). Veamos la siguiente imagen:

![Obtenida desde: https://revistapaideia.cl/ciclos-economicos-que-son-tipos-y-fases](imagenes/Ejemplos-historicos-de-ciclos-economicos-1.png)

Pasemos ahora a hablar de ciertos componentes de las series de tiempo.

## Tendencia, ciclo, estacionalidad y ruido

-   Tendencia: corresponde al comportamiento general o a la dirección de largo plazo de la serie. Se debe tener cuidado que en algunas variables esto no siempre se cumple.

Veamos el caso para el precio de la acción de LATAM Airlines `r fa("plane-departure", fill = "steelblue")`:

```{r, message=FALSE, warning=FALSE, echo=FALSE}
# install.packages(c("tidyquant", "scales"))  # si no los tienes
library(tidyquant)
library(tidyverse)
library(scales)

ticker <- "LTM.SN"          # Alternativas que a veces se usan: "LTM", "LTMAQ" (histórico OTC)
desde  <- "2018-01-01"

# 1) Descargar precios diarios (OHLC); 'adjusted' incluye dividendos/splits
precios <- tq_get(ticker, from = desde, to = Sys.Date())

# 2) Último dato disponible
ultimo <- precios |> dplyr::slice_tail(n = 1) |> dplyr::pull(adjusted)

# 3) Gráfico
library(ggplot2)
ggplot(precios, aes(date, adjusted)) +
  geom_line(linewidth = 0.8) +
  labs(
    title = "LATAM Airlines Group",
    subtitle = paste0("Último cierre: ",
                      label_dollar(prefix = "$", big.mark = ".", decimal.mark = ",")(ultimo),
                      " CLP (", max(precios$date), ")"),
    x = "Fecha", y = "Precio ajustado (CLP)", caption = "Fuente: Yahoo Finance via tidyquant"
  ) +
  theme_minimal()

```

Miremos ahora el caso en donde filtramos el período 2020 - 2021:

```{r, message=FALSE, warning=FALSE, echo=FALSE}

ticker <- "LTM.SN"
desde  <- "2020-01-01"
hasta  <- "2021-12-31"

# 1) Descargar solo 2020–2022
precios <- tq_get(ticker, from = desde, to = hasta)

# 2) Último precio del período
ultimo <- precios %>% slice_tail(n = 1) %>% pull(adjusted)

# 3) Gráfico
ggplot(precios, aes(date, adjusted)) +
  geom_line(linewidth = 0.8) +
  labs(
    title = "LATAM Airlines Group",
    subtitle = paste0("Último cierre en el rango: ",
                      label_dollar(prefix = "$", big.mark = ".", decimal.mark = ",")(ultimo),
                      " CLP (", max(precios$date), ")"),
    x = "Fecha", y = "Precio ajustado (CLP)",
    caption = "Fuente: Yahoo Finance vía tidyquant"
  ) +
  scale_x_date(date_breaks = "3 months", date_labels = "%Y-%m") +
  theme_minimal()

```

¿Qué pasa si filtramos desde el 2024 a la fecha?

```{r, message=FALSE, warning=FALSE, echo=FALSE}

ticker <- "LTM.SN"
desde  <- "2024-01-01"
hasta  <- "2025-09-26"

# 1) Descargar solo 2020–2022
precios <- tq_get(ticker, from = desde, to = hasta)

# 2) Último precio del período
ultimo <- precios %>% slice_tail(n = 1) %>% pull(adjusted)

# 3) Gráfico
ggplot(precios, aes(date, adjusted)) +
  geom_line(linewidth = 0.8) +
  labs(
    title = "LATAM Airlines Group",
    subtitle = paste0("Último cierre en el rango: ",
                      label_dollar(prefix = "$", big.mark = ".", decimal.mark = ",")(ultimo),
                      " CLP (", max(precios$date), ")"),
    x = "Fecha", y = "Precio ajustado (CLP)",
    caption = "Fuente: Yahoo Finance vía tidyquant"
  ) +
  scale_x_date(date_breaks = "3 months", date_labels = "%Y-%m") +
  theme_minimal()
```

Por esta razón debemos tener cuidado con apresurarnos a tomar conclusiones sobre una serie solo en base a la tendencia.

-   Ciclo: corresponde a la variación propia de la serie en torno a la tendencia que no responde a frecuencias predecibles o fijas.

-   Estacionalidad: corresponde a variaciones de la serie que poseen un comportamiento predecible ya sea semanal, menusal o anual.

-   Ruido: corresponde al componente aleatorio e irregular que no puede ser explicado a través de los otros componentes que generalmente se relaciona con variaciones erráticas e impredecibles que no siguen un patrón.

## ¿Por qué analizamos una serie de tiempo?

Se debe justificar el por qué esto es necesario en el contexto de negocios. Por lo general, el interés científico sobre una serie puede darse por dos razones:

1.  Explicar (por qué)
2.  Predecir (qué y cuánto)

A pesar de esto, el límite entre ambas dinámicas es muy delgado. Veamos el siguiente ejemplo:

\begin{equation}
\ln w_i \;=\; \beta_0 \;+\; \rho\, S_i \;+\; \beta_1 X_i \;+\; \beta_2 X_i^{2} \;+\; \boldsymbol{\gamma}^{\top} Z_i \;+\; \varepsilon_i
\end{equation}

-   $w_i$: salario (normalmente por hora, en términos reales).
-   $S_i$: años de escolaridad
-   $X_i$: experiencia potencial (se utiliza también un coeficiente al cuadrado)
-   $Z_i$: puede incluir variables de género, región, etc.

```{r, message=FALSE, warning=FALSE, echo=FALSE}

# Parámetros "Mincer" (ejemplo)
beta0 <- 2.0           # intercepto
rho   <- 0.08          # retorno a la educación (no afecta la concavidad si S es fijo)
beta1 <- 0.08          # coef. experiencia > 0
beta2 <- -0.0015       # coef. experiencia^2 < 0  -> concavidad
S     <- 12            # años de escolaridad (fijo solo para desplazar el nivel)

# Rango de experiencia (0 a 45 años)
X <- seq(0, 45, by = 0.25)

# log-salario y salario (opcional) según Mincer
ln_w <- beta0 + rho*S + beta1*X + beta2*X^2
w    <- exp(ln_w)

# Vértice (máximo de ln(w))
x_star <- -beta1/(2*beta2)
y_star <- beta0 + rho*S + beta1*x_star + beta2*x_star^2

df <- data.frame(X, ln_w, w)

# Gráfico principal: concavidad en log-salario
p <- ggplot(df, aes(X, ln_w)) +
  geom_line(linewidth = 1) +
  geom_vline(xintercept = x_star, linetype = 2, linewidth = 0.6) +
  labs(
    title = "Curva minceriana: concavidad en log(salario)",
    x = "Experiencia potencial (años)",
    y = "log(salario)"
  ) +
  theme_minimal(base_size = 12)

p
```

Por lo general este modelo se utiliza para poder explicar factores que influyen dentro de la renta de las personas.

Pero ¿qué pasa si en vez de explicar la variable, asumimos que el modelo puede también predecir la variable de interés? `r fa("arrow-up-right-dots", fill = "steelblue")`

-   Pensemos en el comportamiento tradicional que se hace entorno a los promedios de una varriable.

## Predecir, pronosticar y simular

Por lo general predecir se relaciona con contextos más generales que solo estimar el valor futuro de una serie temporal. Se puede referir a estimar el valor de una variable desconocida en distintos contexto temporales, como también estar asociado a variables no temporales (clasificación).

Para el caso de pronosticar, esto conecta por lo general con estimar el valor futuro de una variable (serie de tiempo). En este sentido pronóstico refiere a un contexto más acotado dentro de la dinámica predictiva. **En este sentido, todo pronóstico es una predicción, pero no toda predicción es un pronóstico**.

Una simulación refiere a la generación de múltiples valores futuros posibles a partir de supuestos probabilísticos para medir distribuciones, percentiles, etc.; con esto poder también determinar riesgo relacionado con los valores futuros.

# Algunas técnicas de pronóstico:

Promedio móvil: suaviza datos, útil para detectar tendencia general.

\begin{equation}
\hat{y}_{t+1} \;=\; \frac{1}{k}\sum_{i=0}^{k-1} y_{t-i}
\end{equation}

Suavizamiento exponencial simple: otorga más peso a datos recientes, capta mejor los cambios recientes

\begin{equation}
\hat{y}_{t+1} \;=\; \alpha\, y_t \;+\; (1-\alpha)\,\hat{y}_t,
\qquad 0<\alpha<1
\end{equation}

## Ejemplos numéricos

Datos $y_t$: 100, 104, 110, 120, 115, 118, 130, 128, 135, 140

### Promedio

Pensemos en la situación de negocios más simple. Cálculamos el promedio y esto se convierte en nuestro pronóstico:

$$
\hat{y}_{t+1}=120
$$

### Promedio móvil (k = 3)

$$
\hat{y}_{t+1}=\frac{1}{3}(y_t+y_{t-1}+y_{t-2})
$$

\begin{itemize}
\item $\hat y_{4}=\frac{110+104+100}{3}=104.67$
\item $\hat y_{5}=\frac{120+110+104}{3}=111.33$
\item $\hat y_{6}=\frac{115+120+110}{3}=115.00$
\end{itemize}

Pronóstico $t=11$: $$\hat y_{11}=\frac{140+135+128}{3}=\mathbf{134.33}$$

### Suavizamiento Exponencial Simple ($\alpha=0.3$)

$$
s_{t}=\alpha\,y_t+(1-\alpha)\,s_{t-1},\quad s_1=y_1
$$

\begin{itemize}
\item $s_1=100$
\item $s_2=0.3\cdot 104+0.7\cdot 100=101.20$
\item $s_3=0.3\cdot 110+0.7\cdot 101.20=103.84$
\item $s_4=0.3\cdot 120+0.7\cdot 103.84=108.688$
\end{itemize}

Pronóstico $t=11$: $$s_{10}=\mathbf{129.628}$$

# Actividad aplicada

Somos un equipo de analista y debemos que estimar una "buena manera" de poder saber cuántas atenciones tendrémos en el futuro por causas respiratorias. Utilizaremos el siguiente dataset del Gobierno de Chile:

-   [Atenciones de urgencias de causas respiratorias por semana epidemiológica](https://datos.gob.cl/dataset/atenciones-de-urgencia-causas-respiratorias)

## EDA (exploratorio)

Corresponde a **Exploratory Data Analysis**, lo que implica generar una primera impresión general de los datos.

Para esto podemos aplicar la siguiente librería **DataExplorer** [más info acá](https://github.com/boxuancui/DataExplorer), considerando siempre primero importar el archivo.

```{r message=FALSE, warning=FALSE}

library(readr)
library(tidyverse)
library(DataExplorer)
library(kableExtra)
library(knitr)
library(arrow)


#dataset_converted <- read_csv("data/dataset_converted.csv")
df <- read_parquet("data/at_urg_respiratorio_semanal.parquet")  

df_filtered <- df %>% 
  filter(Causa == "TOTAL CAUSAS SISTEMA RESPIRATORIO")

intro_table <- introduce(df_filtered)

intro_table %>%
  select(rows, columns, discrete_columns, continuous_columns,
         all_missing_columns, total_missing_values) %>% 
  kable(
    format = "latex",
    booktabs = TRUE,
    caption = "Dataset summary from DataExplorer"
  ) %>%
  kable_styling(
    font_size = 5,
    latex_options = c("hold_position", "striped")
  )


```

El análisis más detallado se puede obtener con el siguiente código:

```{r message=FALSE, warning=FALSE}
#| eval: false
#| include: true
#| 
create_report(df_filtered)
```

Con esto podemos darnos una primera impresión de los datos que contiene el archivo descargado, como también algunas carácteristicas de cada variable.

No centraremos en el total de atenciones para un centro de atención en particular; para esto generamos los siguientes filtro:

```{r message=FALSE, warning=FALSE}
#| eval: true
#| include: true


sotero_01 <- 
  df_filtered %>% 
  filter(RegionCodigo == 13 
                       & ServicioSaludCodigo == 14 
                       & ComunaCodigo == 13201
                       & EstablecimientoGlosa == "Complejo Hospitalario Dr. Sótero del Río (Santiago, Puente Alto)") %>%
  select(EstablecimientoGlosa, Anio, NumTotal, Causa) %>% 
  filter(Causa == "TOTAL CAUSAS SISTEMA RESPIRATORIO") %>% 
  group_by(EstablecimientoGlosa, Anio) %>%  
  summarise(total_casos = sum(NumTotal))

sotero_01 %>%
  kable(
    format = "latex",
    booktabs = TRUE,
    caption = "Atenciones por año"
  ) %>%
  kable_styling(
    font_size = 5,
    latex_options = c("hold_position", "striped")
  )

```

```{r message=FALSE, warning=FALSE}
#| eval: true
#| include: true

graph_01 <- 
  ggplot(sotero_01) + 
  geom_line(aes(Anio, total_casos))

graph_01
```

```{r message=FALSE, warning=FALSE}
#| eval: true
#| include: true
#| echo: false

# === Parámetros de pronóstico ===
k      <- 3      # ventana del promedio móvil
alpha  <- 0.30   # suavizamiento exponencial (0<alpha<1)

# === 1) Normalizar nombres y ordenar ===
df <- sotero_01 %>%
  rename(
    Anio       = dplyr::matches("(?i)^(anio|year)$"),
    Atenciones = dplyr::matches("(?i)^(total_casos|atenciones|valor|count)$")
  ) %>%
  arrange(Anio) %>% 
  filter(Anio != 2025) %>% 
  ungroup()

y <- df$Atenciones

# Chequeo mínimo
stopifnot(length(y) >= k, alpha > 0, alpha < 1)

# === 2) Pronóstico por Promedio Móvil (PM) ===
pm_forecast <- mean(tail(y, k))  # \hat{y}_{T+1} = promedio de los últimos k

# === 3) Pronóstico por Suavizamiento Exponencial Simple (SES) ===
# s_t = alpha*y_t + (1-alpha)*s_{t-1}; pronóstico \hat{y}_{T+1} = s_T
s <- y[1]
for (i in 2:length(y)) {
  s <- alpha*y[i] + (1 - alpha) * s
}
ses_forecast <- s

# === 4) Construir tabla final (agrega fila del año siguiente con pronósticos) ===
next_year <- max(df$Anio) + 1

tabla_forecasts <- df %>%
  add_row(Anio = next_year, Atenciones = NA_real_) %>%
  mutate(
    `PM(k)`        = c(rep(NA_real_, n() - 1), pm_forecast),
    `SES(alpha)`   = c(rep(NA_real_, n() - 1), ses_forecast)
  )

tabla_forecasts %>%
  kable(
    format  = "latex",
    booktabs = TRUE,
    caption = sprintf(
      "Atenciones por año con pronósticos: PM (k=%d) y SES (\\alpha=%.2f) para %d",
      k, alpha, next_year
    )
  ) %>%
  kable_styling(
    font_size = 8,
    latex_options = c("hold_position", "striped")
  )
```

Con esta simple metodología podemos plantear un pronóstico para lo que queda del año 2025.

## Pregunta

1.  ¿Que conclusión puede sacar el promedio móvil? ¿Del suavizamiento?
2.  ¿Cómo evaluaría el pronóstico generado?

# Simulaciones de Monte Carlo

Una simulación corresponde a imitar en un entorno controlado para experimentar posibles comportamientos futuros de un sistema particular. En este caso lo que se simula es el valor futuro de la serie de tiempo que estamos intentando predecir.

El concepto de **Monte Carlo** corresponde al muestreo aleatorio repetido de múltiples valores futuro para poder incorporar incertidumbre dentro de nuestras predicciones.

En base a la serie ya analizada, definimos una simulación de montecarlo en base a lo siguiente:

1.  Pronóstico base: calculas un número para el próximo año con dos métodos simples.

2.  Error histórico: miras cómo se equivocaron esos métodos en el pasado (residuales = dato real − pronóstico de 1 paso). Esa lista de errores es tu “bolsa” de incertidumbre.

3.  Simular futuros: repites miles de veces: sacas al azar un error de la bolsa (con reemplazo), se lo sumas al pronóstico base ⇒ obtienes un posible futuro.

4.  Resultado: miles de posibles valores futuros (una distribución).

```{r message=FALSE, warning=FALSE}
#| eval: true
#| include: true
#| echo: false

set.seed(123)

# =========================
# Parámetros del ejercicio
# =========================
k      <- 3         # ventana Promedio Móvil
alpha  <- 0.30      # SES
B      <- 10000     # simulaciones
capacidad_max <- NA_real_   # pon un número si quieres calcular prob. (p.ej., 20000)

# ==============
# Preparar datos
# ==============
df <- sotero_01 %>%
  rename(
    Anio       = Anio,
    Atenciones = total_casos
  ) %>%
  filter(Anio != 2025) %>%
  arrange(Anio)


stopifnot(nrow(df) >= k + 2)

y <- df$Atenciones
Tobs <- length(y)
anio_sig <- max(df$Anio) + 1

# ===========================
# 1) Promedio Móvil (PM, k)
# ===========================
# Pronóstico puntual:
pm_hat_T1 <- mean(tail(y, k))

# Fitted one-step-ahead para residuales (a partir de t=k):
pm_fitted <- sapply(k:Tobs, function(t) mean(y[(t-k+1):t]))
pm_resid  <- y[k:Tobs] - pm_fitted

# Distribución de error por bootstrap de residuales:
pm_err_boot <- sample(pm_resid, size = B, replace = TRUE)
pm_sim_T1   <- pmax(0, pm_hat_T1 + pm_err_boot)  # truncar a 0 si aplica

# ===============================
# 2) Suavizamiento Exponencial
# ===============================
# Suavizado y fitted:
s <- y[1]
ses_fitted <- rep(NA_real_, Tobs)
ses_fitted[1] <- s
for (t in 2:Tobs) {
  s <- alpha * y[t] + (1 - alpha) * s
  ses_fitted[t] <- s
}
ses_hat_T1 <- ses_fitted[Tobs]           # pronóstico
ses_resid  <- y[-1] - ses_fitted[-Tobs]  # residuales 1-step (del 2 al T)

# Bootstrap de residuales:
ses_err_boot <- sample(ses_resid, size = B, replace = TRUE)
ses_sim_T1   <- pmax(0, ses_hat_T1 + ses_err_boot)

# =========================
# 3) Resúmenes de simulación
# =========================
qfun <- function(x) {
  qs <- quantile(x, c(0.05, 0.95), names = FALSE, na.rm = TRUE)
  tibble::tibble(
    Mediana = median(x, na.rm = TRUE),
    P5     = qs[1],
    P95    = qs[2]
  )
}

pm_summ  <- qfun(pm_sim_T1)
ses_summ <- qfun(ses_sim_T1)

prob_cap_pm  <- if (is.na(capacidad_max)) NA_real_ else mean(pm_sim_T1  >= capacidad_max)
prob_cap_ses <- if (is.na(capacidad_max)) NA_real_ else mean(ses_sim_T1 >= capacidad_max)

tabla_mc <- tibble::tibble(
  Metodo                 = c(sprintf("PM (k=%d)", k), sprintf("SES (α=%.2f)", alpha)),
  `Pronóstico puntual`   = c(pm_hat_T1, ses_hat_T1),
  `Mediana MC`           = c(pm_summ["Mediana"], ses_summ["Mediana"]),
  `P5 MC`                = c(pm_summ["P5"], ses_summ["P5"]),
  `P95 MC`               = c(pm_summ["P95"], ses_summ["P95"]),
  `Prob ≥ capacidad`     = c(prob_cap_pm, prob_cap_ses)
)

# =========================
# 4) Tabla para PDF (LaTeX)
# =========================

tabla_mc %>%
  kable(
    format  = "latex",
    booktabs = TRUE,
    digits = 1,
    caption = sprintf(
      "Pronóstico para %d con intervalos Monte Carlo (B=%d). %s",
      anio_sig, B,
      if (is.na(capacidad_max)) "" else sprintf("Capacidad = %.0f", capacidad_max)
    )
  ) %>%
  kable_styling(
    font_size = 9,
    latex_options = c("hold_position", "striped")
  )
```

En términos de distribuciones:

```{r}
#| label: fig-sim-dists
#| fig-cap: "Distribuciones predictivas (bootstrap) para PM y SES: mediana (línea sólida) y P5/P95 (líneas punteadas)."
#| fig-width: 7
#| fig-height: 4
#| fig-pos: 'H'
#| echo: false

stopifnot(exists("pm_sim_T1"), exists("ses_sim_T1"))

sims <- tibble(
  value  = c(pm_sim_T1, ses_sim_T1),
  method = factor(c(
    rep(sprintf("PM (k=%s)", if (exists("k")) k else "?"),   length(pm_sim_T1)),
    rep(sprintf("SES (α=%s)", if (exists("alpha")) alpha else "?"), length(ses_sim_T1))
  ))
)

sumstats <- sims %>%
  group_by(method) %>%
  summarise(
    median = median(value, na.rm = TRUE),
    p5     = quantile(value, 0.05, na.rm = TRUE, names = FALSE),
    p95    = quantile(value, 0.95, na.rm = TRUE, names = FALSE),
    .groups = "drop"
  )

ggplot(sims, aes(x = value, fill = method, color = method)) +
  geom_density(alpha = 0.25, adjust = 1) +
  geom_vline(data = sumstats, aes(xintercept = median, color = method), linewidth = 0.4) +
  geom_vline(data = sumstats, aes(xintercept = p5,     color = method), linetype = "dashed", linewidth = 0.3) +
  geom_vline(data = sumstats, aes(xintercept = p95,    color = method), linetype = "dashed", linewidth = 0.3) +
  (if (exists("capacidad_max") && !is.na(capacidad_max))
      geom_vline(xintercept = capacidad_max, linetype = "dotdash", linewidth = 0.4) else NULL) +
  labs(
    x = expression(Y[T+1]~"(simulado)"),
    y = "Densidad",
    title = "Distribuciones predictivas por bootstrap",
    subtitle = sprintf("B ≈ %s simulaciones por método", format(length(pm_sim_T1), big.mark = ","))
  ) +
  theme_minimal(base_size = 11)
```

```{r}
#| label: fig-ts-futuro
#| fig-cap: "Serie anual con distribución del pronóstico en T+1 (PM y SES)."
#| fig-width: 7
#| fig-height: 4
#| fig-pos: 'H'
#| echo: false

# --- Datos base: asume sotero_01 con año y atenciones ---
df <- sotero_01 %>%
  rename(
    Anio       = Anio,
    Atenciones = total_casos
  ) %>%
  filter(Anio != 2025) %>% 
  arrange(Anio)

k     <- if (exists("k")) k else 3
alpha <- if (exists("alpha")) alpha else 0.30
B     <- if (exists("B")) B else 10000

y <- df$Atenciones
Tobs <- length(y)
next_year <- max(df$Anio) + 1

# --- Si no existen simulaciones, calcúlalas (bootstrap de residuales) ---
if (!exists("pm_sim_T1") || !exists("ses_sim_T1")) {
  # PM (k)
  pm_hat    <- mean(tail(y, k))
  pm_fitted <- sapply(k:Tobs, function(t) mean(y[(t-k+1):t]))
  pm_resid  <- y[k:Tobs] - pm_fitted
  pm_sim_T1 <- pmax(0, pm_hat + sample(pm_resid, B, replace = TRUE))

  # SES (α)
  s <- y[1]; ses_fitted <- numeric(Tobs); ses_fitted[1] <- s
  for (t in 2:Tobs) { s <- alpha*y[t] + (1-alpha)*s; ses_fitted[t] <- s }
  ses_hat    <- ses_fitted[Tobs]
  ses_resid  <- y[-1] - ses_fitted[-Tobs]
  ses_sim_T1 <- pmax(0, ses_hat + sample(ses_resid, B, replace = TRUE))
}

# --- Data frames para gráfica ---
sims <- tibble(
  value  = c(pm_sim_T1, ses_sim_T1),
  method = factor(rep(c(sprintf("PM (k=%d)", k), sprintf("SES (α=%.2f)", alpha)),
                      c(length(pm_sim_T1), length(ses_sim_T1))))
)

sumstats <- sims %>%
  group_by(method) %>%
  summarise(
    med = median(value),
    p5  = quantile(value, 0.05, names = FALSE),
    p95 = quantile(value, 0.95, names = FALSE),
    .groups = "drop"
  ) %>%
  # separar ligeramente PM y SES en el eje x para que no se monten
  mutate(x = next_year + if_else(method == levels(method)[1], -0.15, 0.15))

sims_plot <- sims %>%
  mutate(x = next_year + if_else(method == levels(method)[1], -0.15, 0.15))

# --- Plot: serie histórica + distribución futura ---
ggplot() +
  geom_line(data = df, aes(Anio, Atenciones)) +
  geom_point(data = df, aes(Anio, Atenciones), size = 1.3) +
  # distribución en T+1: violín
  geom_violin(data = sims_plot, aes(x, value, fill = method),
              width = 0.25, alpha = 0.30, color = NA) +
  # intervalo P5–P95 y mediana
  geom_linerange(data = sumstats, aes(x, ymin = p5, ymax = p95, color = method),
                 linewidth = 0.6) +
  geom_point(data = sumstats, aes(x, y = med, color = method), size = 2) +
  scale_x_continuous(breaks = c(df$Anio, next_year),
                     labels = c(df$Anio, paste0(next_year, " (T+1)")),
                     guide  = guide_axis(angle = 45)) +
  labs(
    x = "Año", y = "Atenciones",
    fill = "Método", color = "Método",
    title = "Serie de tiempo con distribución del pronóstico",
    subtitle = "Barra: P5–P95"
  ) +
  theme_minimal(base_size = 11)
```

Para este caso, el principal valor de las simulaciones viene dado por la posibilidad de seleccionar metodos con un mayor o menor grado de incertidumbre; por otra parte, se podría también trabajar en sensibilizar el posible impacto de la predicción ya obtenida en base a los valores de relevantes de la simulación.

# Referencias

-   Vecillas Martin, D., Berruezo Fernández, C., & Gento Municio, A. M. (2025). Systematic Review of Discrete Event Simulation in Healthcare and Statistics Distributions. Applied Sciences, 15(4), 1861. [Enlace aquí](https://www.mdpi.com/2076-3417/15/4/1861#:~:text=53,CrossRef)

-   Heins, J., Schoenfelder, J., Heider, S., Heller, A. R., & Brunner, J. O. (2022). A scalable forecasting framework to predict COVID-19 hospital bed occupancy. INFORMS Journal on Applied Analytics, 52(6), 508-523. [Enlace aquí](https://opus.bibliothek.uni-augsburg.de/opus4/frontdoor/deliver/index/docId/92025/file/92025.pdf#:~:text=jens.brunner%40uni,care%20units%20and%20regular%20wards)

-   Harper, P. R., & Shahani, A. K. (2002). Modelling for the planning and management of bed capacities in hospitals. Journal of the Operational research Society, 53(1), 11-18.
